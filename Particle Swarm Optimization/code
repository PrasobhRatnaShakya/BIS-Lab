# Step 1: Upload the image manually
from google.colab import files
uploaded = files.upload() # Upload dialog will pop up
# Get uploaded filename
img_path = list(uploaded.keys())[0]
print(f"Uploaded image: {img_path}")
# Step 2: Import packages
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import cv2
import random
# Step 3: Load image in grayscale
img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
if img is None:
raise FileNotFoundError("Image not found or could not be
read.")
pixels = img.flatten()
# Step 4: Define fitness function (Otsu between-class variance)
def otsu_between_class_variance(threshold, pixels):
threshold = int(np.clip(threshold, 0, 255))
hist, _ = np.histogram(pixels, bins=256, range=(0,256))
total = pixels.size
w0 = hist[:threshold].sum() / total
w1 = hist[threshold:].sum() / total
if w0 == 0 or w1 == 0:
return 0.0
mu0 = np.sum(np.arange(0, threshold) * hist[:threshold]) /
(hist[:threshold].sum() + 1e-8)
mu1 = np.sum(np.arange(threshold, 256) * hist[threshold:]) /
(hist[threshold:].sum() + 1e-8)
return w0 * w1 * (mu0 - mu1) ** 2
def fitness(threshold, pixels):
return -otsu_between_class_variance(threshold, pixels)
# Step 5: PSO implementation
class Particle:
def __init__(self, min_x, max_x):
18
self.position = random.uniform(min_x, max_x)
self.velocity = random.uniform(-10, 10)
self.best_position = self.position
self.best_value = float("inf")
def pso_optimize(
pixels,
n_particles=20,
n_iters=50,
min_x=0,
max_x=255,
w=0.7,
c1=1.5,
c2=1.5,
):
swarm = [Particle(min_x, max_x) for _ in range(n_particles)]
g_best_position = swarm[0].position
g_best_value = float("inf")
history = []
for it in range(n_iters):
for p in swarm:
f = fitness(p.position, pixels)
if f < p.best_value:
p.best_value = f
p.best_position = p.position
if f < g_best_value:
g_best_value = f
g_best_position = p.position
for p in swarm:
r1 = random.random()
r2 = random.random()
cognitive = c1 * r1 * (p.best_position - p.position)
social = c2 * r2 * (g_best_position - p.position)
p.velocity = w * p.velocity + cognitive + social
p.position += p.velocity
p.position = max(min_x, min(max_x, p.position))
history.append((it, g_best_position, g_best_value))
print(f"Iteration {it}: Best threshold =
{g_best_position:.2f}, Fitness = {g_best_value:.6e}")
hist_df = pd.DataFrame(history, columns=["Iteration", "Best
Threshold", "Fitness"])
return int(round(g_best_position)), hist_df
19
# Step 6: Run PSO to find optimal threshold
best_threshold, history_df = pso_optimize(pixels)
print(f"Optimal threshold found by PSO: {best_threshold}")
# Step 7: Apply threshold and visualize results
_, segmented = cv2.threshold(img, best_threshold, 255,
cv2.THRESH_BINARY)
plt.figure(figsize=(12, 5))
plt.subplot(1, 3, 1)
plt.imshow(img, cmap='gray')
plt.title('Original Image')
plt.axis('off')
plt.subplot(1, 3, 2)
plt.imshow(segmented, cmap='gray')
plt.title(f'Segmented Image\nThreshold = {best_threshold}')
plt.axis('off')
plt.subplot(1, 3, 3)
plt.plot(history_df["Iteration"], -history_df["Fitness"])
plt.xlabel("Iteration")
plt.ylabel("Otsu Score")
plt.title("PSO Convergence")
plt.tight_layout()
plt.show()
